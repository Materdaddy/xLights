/////////////////////////////////////////////////////////////////////////////
// Name:        serport.cpp
// Purpose:
// Author:      Joachim Buermann (adapted for xLights by Matt Brown)
// Copyright:   (c) 2010 Joachim Buermann
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <sstream>
#include "fifo.cpp"

#if defined (WIN32)
# define snprintf _snprintf
#endif

namespace ctb {

    /*!
	 \enum Parity

	 \brief Defines the different modes of parity checking. Under
	 Linux, the struct termios will be set to provide the wanted
	 behaviour.
    */
    enum Parity
    {
	   /*! no parity check */
	   ParityNone,
	   /*! odd parity check */
	   ParityOdd,
	   /*! even parity check */
	   ParityEven,
	   /*! mark (not implemented yet) */
	   ParityMark,
	   /*! space (not implemented yet) */
	   ParitySpace
    };

    /*!
	 \enum SerialLineState

	 Defines the different modem control lines. The value for
	 each item are defined in /usr/include/bits/ioctl-types.h.
	 This is the linux definition. The window version translate
	 each item in it's own value.
	 modem lines defined in ioctl-types.h
	 \code
	 #define TIOCM_LE	0x001
	 #define TIOCM_DTR	0x002
	 #define TIOCM_RTS	0x004
	 #define TIOCM_ST	0x008
	 #define TIOCM_SR	0x010
	 #define TIOCM_CTS	0x020
	 #define TIOCM_CAR	0x040
	 #define TIOCM_RNG	0x080
	 #define TIOCM_DSR	0x100
	 #define TIOCM_CD	TIOCM_CAR
	 #define TIOCM_RI	TIOCM_RNG
	 \endcode
    */
    enum SerialLineState
    {
	   /*! Data Carrier Detect (read only) */
	   LinestateDcd = 0x040,
	   /*! Clear To Send (read only) */
	   LinestateCts = 0x020,
	   /*! Data Set Ready (read only) */
	   LinestateDsr = 0x100,
	   /*! Data Terminal Ready (write only) */
	   LinestateDtr = 0x002,
	   /*! Ring Detect (read only) */
	   LinestateRing = 0x080,
	   /*! Request To Send (write only) */
	   LinestateRts = 0x004,
	   /*! no active line state, use this for clear */
	   LinestateNull = 0x000
    };

    /*!
	 \struct SerialPort_DCS

	 The device control struct for the serial communication class.
	 This struct should be used, if you refer advanced parameter.
    */
    struct SerialPort_DCS
    {
	   /*! the baudrate */
	   int baud;
	   /*! the parity */
	   Parity parity;
	   /*! the wordlen */
	   unsigned char wordlen;
	   /*! count of stopbits */
	   unsigned char stopbits;
	   /*! rtscts flow control */
	   bool rtscts;
	   /*! XON/XOFF flow control */
	   bool xonxoff;
	   /*! buffer for internal use */
	   char buf[16];
	   SerialPort_DCS() {
		  baud = 38400;
		  parity = ParityNone;
		  wordlen = 8;
		  stopbits = 1;
		  rtscts = false;
		  xonxoff = false;
	   };
	   // to avoid memory leak warnings generated by swig
	   ~SerialPort_DCS() {};
	   /*!
		\brief returns the internal settings of the DCS as a human
		readable string like '8N1 115200'.
		\return the internal settings as null terminated string
	   */
	   char* GetSettings() {
		  const char ac[5] = {'N','O','E','M','S'};
		  memset(buf,0,sizeof(buf));
		  snprintf(buf,sizeof(buf)-1,"%i%c%i %i",
				 wordlen,
				 ac[parity],
				 stopbits,
				 baud);
		  return buf;
	   };
    };

/*!
  \struct SerialPort_EINFO

  The internal communication error struct. It contains the number
  of each error (break, framing, overrun and parity) since opening
  the serial port. Each error number will be cleared if the open
  method was called.
*/
    struct SerialPort_EINFO
    {
	   /*! number of breaks */
	   int brk;
	   /*! number of framing errors */
	   int frame;
	   /*! number of overrun errors */
	   int overrun;
	   /*! number of parity errors */
	   int parity;
	   SerialPort_EINFO() {
		  brk = frame = overrun = parity = 0;
	   };
    };

    /*!
	 \enum SerialPortIoctls

	 The following Ioctl calls are only valid for the SerialPort
	 class.
    */
    enum SerialPortIoctls {
	   /*!
		Reset the connected device. For a serial (RS232) connection,
		a break is send. For GPIB the IFC (Interface Clear) line is
		set.
	   */
	   CTB_RESET,
	   /*!
		Get all numbers of occured communication errors (breaks
		framing, overrun and parity), so the args parameter of
		the Ioctl call must pointed to a SerialPort_EINFO
		struct.
	   */
	   CTB_SER_GETEINFO,
	   /*!
		Get integer 1, if a break occured since the last call
		so the args parameter of the Ioctl method must pointed
		to an integer value. If there was no break, the result
		is integer 0.
	   */
	   CTB_SER_GETBRK,
	   /*!
		Get integer 1, if a framing occured since the last call
		so the args parameter of the Ioctl method must pointed
		to an integer value. If there was no break, the result
		is integer 0.
	   */
	   CTB_SER_GETFRM,
	   /*!
		Get integer 1, if a overrun occured since the last call
		so the args parameter of the Ioctl method must pointed
		to an integer value. If there was no break, the result
		is integer 0.
	   */
	   CTB_SER_GETOVR,
	   /*!
		Get integer 1, if a parity occured since the last call
		so the args parameter of the Ioctl method must pointed
		to an integer value. If there was no break, the result
		is integer 0.
	   */
	   CTB_SER_GETPAR,
	   /*!
		Get the number of bytes received by the serial port driver
		but not yet read by a Read Operation.
	   */
	   CTB_SER_GETINQUE
    };

/*!
  \class SerialPort_x
  SerialPort_x is the basic class for serial communication via
  the serial comports. It is also an abstract class and defines
  all necessary methods, which the derivated plattform depended
  classes must be invoke.
*/
    class SerialPort_x
    {
    protected:
	   /*!
		\brief internal fifo (first in, first out queue) to put back
		already readed bytes into the reading stream. After put back a single
		byte or sequence of characters, you can read them again with the
		next Read call.
	   */
	   Fifo* m_fifo;
	   enum {
		  /// fifosize of the putback fifo
		  fifoSize = 256
	   };
	   /*!
		Close the interface (internally the file descriptor, which was
		connected with the interface).
		\return zero on success, otherwise -1.
	   */
	   virtual int CloseDevice() = 0;
	   /*!
		Open the interface (internally to request a file descriptor for the
		given interface). The second parameter is a undefined pointer of a
		device dependent data struct. It must be undefined, because different
		devices have different settings. A serial device like the com ports
		points here to a data struct, includes information like baudrate,
		parity, count of stopbits and wordlen and so on. Another devices
		(for example a IEEE) needs a adress and EOS (end of string character)
		and don't use baudrate or parity.
		\param devname the name of the device, presents the given interface.
		Under windows for example COM1, under Linux /dev/cua0. Use wxCOMn to
		avoid plattform depended code (n is the serial port number, beginning
		with 1).
		\param dcs untyped pointer of advanced device parameters,
		\sa struct dcs_devCUA (data struct for the serail com ports)
		\return zero on success, otherwise -1
	   */
	   virtual int OpenDevice(const wxString& devname, void* dcs = 0L) = 0;
	   /*!
		\brief contains the internal settings of the serial port like
		baudrate, protocol, wordlen and so on.
	   */
	   SerialPort_DCS m_dcs;
	   /*!
		\brief contains the internal (os specific) name of the serial
		device.
	   */
	   wxString m_devname;
    public:

	   /*!
		\enum FlowControl
		\brief Specifies the flow control.


	   */
	   enum FlowControl
	   {
		  NoFlowControl, /*!< No flow control at all */

		  RtsCtsFlowControl, /*!< Enable RTS/CTS hardware flow control */

		  XonXoffFlowControl /*!< Enable XON/XOFF protocol */
	   };

	   SerialPort_x() {
		m_fifo = new Fifo(fifoSize);
		m_devname = _("");
           };
	   virtual ~SerialPort_x() {
		delete m_fifo;
	   };

	   /*!
		\param devname name of the interface, we want to open
		\param dcs a untyped pointer to a device control struct. If
		he is NULL, the default device parameter will be used.
		\return the new file descriptor, or -1 if an error occurred

		The pointer dcs will be used for special device dependent
		settings. Because this is very specific, the struct or
		destination of the pointer will be defined by every device
		itself. (For example: a serial device class should refer
		things like parity, word length and count of stop bits,
		a IEEE class adress and EOS character).
	   */
	   int Open(const wxString& devname,void* dcs=0L) {
		  return OpenDevice(devname,dcs);
	   };

	   /*!
		Closed the interface. Internally it calls the CloseDevice()
		method, which must be defined in the derivated class.
		\return zero on success, or -1 if an error occurred.
	   */
	   int Close() {return CloseDevice();};

	   /*!
		\brief request the current settings of the connected serial port
		as a null terminated string.
		\return the settings as a string like '8N1 115200'
	   */
	   virtual char* GetSettingsAsString() {
		  return m_dcs.GetSettings();
	   };

	   /*!
		\brief Many operating characteristics are only possible for
		special devices. To avoid the need of a lot of different functions
		and to give the user a uniform interface, all this special
		operating instructions will covered by one Ioctl method (like
		the linux ioctl call).
		The Ioctl command (cmd) has encoded in it whether the argument
		is an in parameter or out parameter, and the size of the
		argument args in bytes. Macros and defines used in specifying an
		ioctl request are located in iobase.h and the header file for
		the derivated device (for example in serportx.h).
		\param cmd one of SerialPortIoctls specify the ioctl request.
		\param args is a typeless pointer to a memory location, where
		Ioctl reads the request arguments or write the results.
		Please note, that an invalid memory location or size involving
		a buffer overflow or segmention fault!
	   */
	   virtual int Ioctl(int cmd,void* args) {return -1;};

	   /*!
		\brief Opens a serial port in a user likely way. Instead of
		using the Device Control Struct just input your parameter in a
		more intuitive manner.
		\param portname the name of the serial port
		\param baudrate any baudrate, also an unusual one, if your
		serial device support them
		\param protocol a string with the number of databits (5...8),
		the parity setting (N=None,O=Odd,E=Even,M=Mark,S=Space), also
		in lower case, and the count of stopbits (1...2)
		\param flowControl one of NoFlowControl, RtsCtsFlowControl or
		XonXoffFlowControl.
		\return the new file descriptor, or -1 if an error occurred
	    */
	   int Open( const wxString& portname, int baudrate,
			   const char* protocol = "8N1",
			   FlowControl flowControl = NoFlowControl )
    {
	   SerialPort_DCS dcs;

	   dcs.baud = baudrate;

	   // default wordlen is 8
	   if( ( protocol[ 0 ] >= '5' ) && ( protocol[ 0 ] <= '8' )) {

		  dcs.wordlen = protocol[ 0 ] - '0';

	   }
	   else {

		  return -1;

	   }

	   // protocol is given as a string like "8N1", the first
	   // character specifies the data bits (5...8), the second
	   // the parity (None,Odd,Even,Mark,Space).
	   // The third character defines the stopbit (1...2).
	   switch( protocol[ 1 ] ) {
	   case 'N': case 'n': dcs.parity = ParityNone; break;
	   case 'O': case 'o': dcs.parity = ParityOdd; break;
	   case 'E': case 'e': dcs.parity = ParityEven; break;
	   case 'M': case 'm': dcs.parity = ParityMark; break;
	   case 'S': case 's': dcs.parity = ParitySpace; break;
		  // all other parameters cause an error!
	   default: return -1;
	   }
	   // default stopbits is 1
	   if( ( protocol[ 2 ] >= '1' ) && ( protocol[ 2 ] <= '2' )) {

		  dcs.stopbits = protocol[ 2 ] - '0';

	   }
	   else {

		  return -1;

	   }
	   // default flow control is disabled
	   dcs.rtscts = ( flowControl == RtsCtsFlowControl );

	   dcs.xonxoff = ( flowControl == XonXoffFlowControl );

	   // save the settings in the internal dcs for later use
	   m_dcs = dcs;

	   return OpenDevice( portname, &m_dcs );
    }

	   /*!
		\brief Sendbreak transmits a continuous stream of zero-valued
		bits for a specific duration.
		\param duration If duration is zero, it transmits
		zero-valued bits for at least 0.25 seconds, and  not more that
		0.5 seconds. If duration is not zero, it sends zero-valued bits
		for  duration*N  seconds, where N is at least 0.25, and not more
		than 0.5.
		\return zero on success, -1 if an error occurs.
	   */
	   virtual int SendBreak(int duration) = 0;

	   /*!
		\brief Set the baudrate (also non-standard)
		Please note: Non-standard baudrates like 70000 are not supported
		by each UART and depends on the RS232 chipset you apply.
		\param baudrate the new baudrate
		\return zero on success, -1 if an error occurs
	   */
	   virtual int SetBaudrate( int baudrate ) = 0;

    };

} // namespace ctb

#if defined (WIN32)
# include "ser_win32.cpp"
#else
# include "ser_posix.cpp"
#endif
